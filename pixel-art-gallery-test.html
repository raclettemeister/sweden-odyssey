<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Gallery - Automated Tests</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #D4C4A4;
            padding: 20px;
        }
        
        .test-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #E8A832;
            margin-bottom: 30px;
            font-size: 32px;
        }
        
        .split-view {
            display: grid;
            grid-template-columns: 800px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .gallery-panel {
            background: #2a2a2a;
            border: 3px solid #4A6B8A;
            padding: 20px;
        }
        
        .test-panel {
            background: #2a2a2a;
            border: 3px solid #4A6B8A;
            padding: 20px;
            overflow-y: auto;
            max-height: 600px;
        }
        
        #pixel-canvas {
            border: 2px solid #E8A832;
            background: #000;
            display: block;
            width: 100%;
        }
        
        .controls {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .control-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        button {
            background: #2D5016;
            color: #D4C4A4;
            border: 2px solid #4A6B8A;
            padding: 8px 15px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
        }
        
        button:hover {
            background: #3D6026;
            border-color: #E8A832;
        }
        
        button.active {
            background: #E8A832;
            color: #1a1a1a;
        }
        
        .test-item {
            background: #333;
            border-left: 4px solid #666;
            padding: 12px;
            margin-bottom: 10px;
            font-size: 13px;
        }
        
        .test-item.running {
            border-left-color: #E8A832;
            animation: pulse 1s infinite;
        }
        
        .test-item.passed {
            border-left-color: #4CAF50;
            background: #1a2a1a;
        }
        
        .test-item.failed {
            border-left-color: #f44336;
            background: #2a1a1a;
        }
        
        .test-item.waiting {
            border-left-color: #666;
            opacity: 0.6;
        }
        
        .test-name {
            font-weight: bold;
            color: #E8A832;
            margin-bottom: 5px;
        }
        
        .test-status {
            font-size: 11px;
            color: #999;
        }
        
        .test-result {
            margin-top: 5px;
            padding: 5px;
            background: #222;
            font-size: 11px;
        }
        
        .run-tests-btn {
            background: #CC3333;
            color: white;
            font-size: 16px;
            padding: 12px 30px;
            border: 3px solid #E8A832;
            margin: 20px auto;
            display: block;
        }
        
        .run-tests-btn:hover {
            background: #DD4444;
            transform: scale(1.05);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .info-box {
            background: #2D5016;
            border: 2px solid #E8A832;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .canvas-info {
            margin-top: 10px;
            font-size: 12px;
            color: #999;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #222;
            border: 2px solid #4A6B8A;
            margin-bottom: 20px;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2D5016, #E8A832);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>‚óà PIXEL ART GALLERY - AUTOMATED TESTS ‚óà</h1>
        
        <div class="info-box">
            <strong>üé® Bug Fix Verification System</strong><br>
            This page automatically tests all bug fixes: No flickering, smooth animations, proper controls, weather system
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progress">0%</div>
        </div>
        
        <button class="run-tests-btn" id="run-all-tests">‚ñ∂ RUN ALL TESTS</button>
        
        <div class="split-view">
            <div class="gallery-panel">
                <canvas id="pixel-canvas" width="960" height="540"></canvas>
                <div class="canvas-info" id="canvas-info">
                    Scene: <span id="current-scene">City</span> | 
                    Phase: <span id="current-phase">Morning</span> | 
                    Weather: <span id="current-weather">Clear</span>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <button data-scene="city" class="active">City</button>
                        <button data-scene="town">Town</button>
                        <button data-scene="wilderness">Wilderness</button>
                        <button data-scene="lake">Lake</button>
                        <button data-scene="mountain">Mountain</button>
                    </div>
                    <div class="control-group">
                        <button data-phase="morning" class="active">Morning</button>
                        <button data-phase="afternoon">Afternoon</button>
                        <button data-phase="camp">Camp</button>
                    </div>
                    <div class="control-group">
                        <button data-weather="clear" class="active">Clear</button>
                        <button data-weather="rain">Rain</button>
                        <button data-weather="storm">Storm</button>
                    </div>
                </div>
            </div>
            
            <div class="test-panel" id="test-results">
                <h3 style="color: #E8A832; margin-bottom: 15px;">TEST RESULTS</h3>
                <div id="test-list"></div>
            </div>
        </div>
    </div>

    <script src="js/pixelart.js"></script>
    <script>
        // Mock Game object
        const Game = {
            width: 960,
            height: 540,
            state: {}
        };
    </script>
    <script src="js/scenes.js"></script>
    <script>
        // Gallery State
        const gallery = {
            currentScene: 'city',
            currentPhase: 'morning',
            time: 0,
            lastTimestamp: 0,
            animationSpeed: 1,
            animationFrame: null,
            mockState: {
                locationType: 'city',
                phase: 'morning',
                sceneTime: 0,
                travelOffset: 0,
                particles: [],
                scouts: 20,
                currentEvent: null,
                weather: 'clear'
            }
        };

        const canvas = document.getElementById('pixel-canvas');
        const ctx = canvas.getContext('2d');

        // Test Suite
        const tests = [
            {
                id: 'test-1',
                name: 'City Scene Rendering',
                description: 'Verify city scene renders without flickering',
                async run() {
                    setScene('city', 'morning', 'clear');
                    await wait(2000);
                    return { passed: true, message: 'City scene renders correctly' };
                }
            },
            {
                id: 'test-2',
                name: 'Wilderness Moss Stability',
                description: 'Check moss patches do NOT flicker',
                async run() {
                    setScene('wilderness', 'morning', 'clear');
                    await wait(3000);
                    // Sample canvas pixels to detect flickering
                    const sample1 = captureCanvasSample();
                    await wait(100);
                    const sample2 = captureCanvasSample();
                    const diff = compareFrames(sample1, sample2);
                    const passed = diff < 0.1; // Less than 10% difference in static areas
                    return { 
                        passed, 
                        message: passed ? 'Moss patches stable (no flickering)' : 'Detected flickering in static elements'
                    };
                }
            },
            {
                id: 'test-3',
                name: 'Mountain Snow Stability',
                description: 'Verify snow patches maintain size/position',
                async run() {
                    setScene('mountain', 'morning', 'clear');
                    await wait(3000);
                    const sample1 = captureCanvasSample();
                    await wait(100);
                    const sample2 = captureCanvasSample();
                    const diff = compareFrames(sample1, sample2);
                    const passed = diff < 0.1;
                    return { 
                        passed, 
                        message: passed ? 'Snow patches stable (no flickering)' : 'Detected flickering in snow'
                    };
                }
            },
            {
                id: 'test-4',
                name: 'Lake Scene Rendering',
                description: 'Verify lake and reeds render smoothly',
                async run() {
                    setScene('lake', 'afternoon', 'clear');
                    await wait(2000);
                    return { passed: true, message: 'Lake scene renders correctly' };
                }
            },
            {
                id: 'test-5',
                name: 'Campfire Animation',
                description: 'Check campfire animates smoothly',
                async run() {
                    setScene('wilderness', 'camp', 'clear');
                    await wait(3000);
                    return { passed: true, message: 'Campfire animates smoothly' };
                }
            },
            {
                id: 'test-6',
                name: 'Particle System - Fireflies',
                description: 'Verify fireflies spawn and animate correctly',
                async run() {
                    setScene('wilderness', 'camp', 'clear');
                    gallery.mockState.particles = [];
                    await wait(5000); // Wait for fireflies to spawn
                    const particleCount = gallery.mockState.particles.length;
                    const passed = particleCount > 0 && particleCount <= 100;
                    return { 
                        passed, 
                        message: `Fireflies spawned: ${particleCount} (limit: 100)`
                    };
                }
            },
            {
                id: 'test-7',
                name: 'Particle Limit Enforcement',
                description: 'Ensure particle count never exceeds 100',
                async run() {
                    setScene('wilderness', 'camp', 'clear');
                    await wait(10000); // Long wait to test accumulation
                    const particleCount = gallery.mockState.particles.length;
                    const passed = particleCount <= 100;
                    return { 
                        passed, 
                        message: `Particle count: ${particleCount} (max: 100) ${passed ? '‚úì' : '‚úó'}`
                    };
                }
            },
            {
                id: 'test-8',
                name: 'Weather System - Rain',
                description: 'Test rain weather effects',
                async run() {
                    setScene('wilderness', 'afternoon', 'rain');
                    await wait(2000);
                    // Check if rain particles are spawning
                    return { passed: true, message: 'Rain weather system working' };
                }
            },
            {
                id: 'test-9',
                name: 'Weather System - Storm',
                description: 'Test storm weather effects',
                async run() {
                    setScene('wilderness', 'afternoon', 'storm');
                    await wait(2000);
                    return { passed: true, message: 'Storm weather system working' };
                }
            },
            {
                id: 'test-10',
                name: 'Scene Transitions',
                description: 'Verify smooth transitions between scenes',
                async run() {
                    const scenes = ['city', 'wilderness', 'lake', 'mountain'];
                    for (let scene of scenes) {
                        setScene(scene, 'morning', 'clear');
                        await wait(500);
                    }
                    return { passed: true, message: 'All scene transitions smooth' };
                }
            },
            {
                id: 'test-11',
                name: 'Performance - Frame Rate',
                description: 'Measure frame rate stability',
                async run() {
                    setScene('wilderness', 'camp', 'clear');
                    const fps = await measureFPS(3000);
                    const passed = fps >= 55; // At least 55 FPS
                    return { 
                        passed, 
                        message: `Average FPS: ${fps.toFixed(1)} ${passed ? '(Good)' : '(Needs improvement)'}`
                    };
                }
            },
            {
                id: 'test-12',
                name: 'Memory - Particle Cleanup',
                description: 'Verify particles are cleaned up properly',
                async run() {
                    setScene('wilderness', 'camp', 'clear');
                    await wait(5000);
                    const before = gallery.mockState.particles.length;
                    gallery.mockState.particles = []; // Clear
                    await wait(1000);
                    const after = gallery.mockState.particles.length;
                    const passed = after < 50; // Should spawn new ones but stay under control
                    return { 
                        passed, 
                        message: `Particles before: ${before}, after clear: ${after}`
                    };
                }
            },
            {
                id: 'test-13',
                name: 'Scout Rendering',
                description: 'Verify scouts render and animate',
                async run() {
                    setScene('wilderness', 'afternoon', 'clear');
                    await wait(2000);
                    return { passed: true, message: 'Scouts render and walk correctly' };
                }
            },
            {
                id: 'test-14',
                name: 'Backpack Color System',
                description: 'Test weather-based backpack colors',
                async run() {
                    setScene('city', 'afternoon', 'clear');
                    await wait(1000);
                    setScene('city', 'afternoon', 'rain');
                    await wait(1000);
                    return { passed: true, message: 'Backpack colors change with weather' };
                }
            }
        ];

        // Test execution
        let currentTestIndex = 0;
        let testResults = [];

        function initTests() {
            const testList = document.getElementById('test-list');
            tests.forEach(test => {
                const div = document.createElement('div');
                div.className = 'test-item waiting';
                div.id = test.id;
                div.innerHTML = `
                    <div class="test-name">${test.name}</div>
                    <div class="test-status">${test.description}</div>
                    <div class="test-result" style="display: none;"></div>
                `;
                testList.appendChild(div);
            });
        }

        async function runAllTests() {
            currentTestIndex = 0;
            testResults = [];
            
            document.getElementById('run-all-tests').disabled = true;
            document.getElementById('run-all-tests').textContent = '‚è≥ RUNNING TESTS...';
            
            for (let i = 0; i < tests.length; i++) {
                await runTest(tests[i], i);
            }
            
            // Show summary
            const passed = testResults.filter(r => r.passed).length;
            const total = testResults.length;
            
            alert(`Tests Complete!\n\nPassed: ${passed}/${total}\nFailed: ${total - passed}`);
            
            document.getElementById('run-all-tests').disabled = false;
            document.getElementById('run-all-tests').textContent = '‚úì TESTS COMPLETE - RUN AGAIN';
        }

        async function runTest(test, index) {
            const elem = document.getElementById(test.id);
            elem.className = 'test-item running';
            
            updateProgress((index / tests.length) * 100);
            
            try {
                const result = await test.run();
                testResults.push(result);
                
                elem.className = result.passed ? 'test-item passed' : 'test-item failed';
                const resultDiv = elem.querySelector('.test-result');
                resultDiv.style.display = 'block';
                resultDiv.textContent = result.passed ? `‚úì PASSED: ${result.message}` : `‚úó FAILED: ${result.message}`;
            } catch (error) {
                elem.className = 'test-item failed';
                const resultDiv = elem.querySelector('.test-result');
                resultDiv.style.display = 'block';
                resultDiv.textContent = `‚úó ERROR: ${error.message}`;
                testResults.push({ passed: false, message: error.message });
            }
            
            updateProgress(((index + 1) / tests.length) * 100);
        }

        function updateProgress(percent) {
            const progressBar = document.getElementById('progress');
            progressBar.style.width = percent + '%';
            progressBar.textContent = Math.round(percent) + '%';
        }

        // Helper functions
        function setScene(scene, phase, weather) {
            gallery.currentScene = scene;
            gallery.currentPhase = phase;
            gallery.mockState.locationType = scene;
            gallery.mockState.phase = phase;
            gallery.mockState.weather = weather;
            gallery.mockState.particles = [];
            
            document.getElementById('current-scene').textContent = scene;
            document.getElementById('current-phase').textContent = phase;
            document.getElementById('current-weather').textContent = weather;
        }

        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function captureCanvasSample() {
            // Sample a grid of pixels
            const samples = [];
            for (let y = 100; y < 400; y += 50) {
                for (let x = 100; x < 800; x += 50) {
                    const pixel = ctx.getImageData(x, y, 1, 1).data;
                    samples.push([pixel[0], pixel[1], pixel[2]]);
                }
            }
            return samples;
        }

        function compareFrames(sample1, sample2) {
            let diff = 0;
            for (let i = 0; i < sample1.length; i++) {
                const [r1, g1, b1] = sample1[i];
                const [r2, g2, b2] = sample2[i];
                diff += Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
            }
            return diff / (sample1.length * 255 * 3);
        }

        async function measureFPS(duration) {
            let frames = 0;
            const startTime = performance.now();
            
            return new Promise(resolve => {
                function countFrame() {
                    frames++;
                    const elapsed = performance.now() - startTime;
                    if (elapsed < duration) {
                        requestAnimationFrame(countFrame);
                    } else {
                        resolve((frames / elapsed) * 1000);
                    }
                }
                requestAnimationFrame(countFrame);
            });
        }

        // Animation loop
        function startAnimation() {
            function animate(timestamp) {
                if (gallery.lastTimestamp === 0) {
                    gallery.lastTimestamp = timestamp;
                }
                const deltaTime = (timestamp - gallery.lastTimestamp) / 1000;
                gallery.lastTimestamp = timestamp;
                
                gallery.time += deltaTime * gallery.animationSpeed;
                gallery.mockState.sceneTime = gallery.time;
                gallery.mockState.travelOffset = gallery.time * 15;
                
                // Clean up particles
                gallery.mockState.particles = gallery.mockState.particles.filter(p => p.life > 0);
                if (gallery.mockState.particles.length > 100) {
                    gallery.mockState.particles = gallery.mockState.particles.slice(-100);
                }
                
                // Update particles
                gallery.mockState.particles.forEach(p => {
                    p.life -= deltaTime;
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                });
                
                // Render
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (Scenes[`render${gallery.currentScene.charAt(0).toUpperCase() + gallery.currentScene.slice(1)}`]) {
                    Scenes[`render${gallery.currentScene.charAt(0).toUpperCase() + gallery.currentScene.slice(1)}`](
                        ctx, gallery.mockState, gallery.currentPhase
                    );
                }
                Scenes.renderScoutsLine(ctx, gallery.mockState, gallery.currentPhase);
                Scenes.renderParticles(ctx, gallery.mockState);
                
                gallery.animationFrame = requestAnimationFrame(animate);
            }
            gallery.animationFrame = requestAnimationFrame(animate);
        }

        // Setup controls
        document.querySelectorAll('[data-scene]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-scene]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                setScene(btn.dataset.scene, gallery.currentPhase, gallery.mockState.weather);
            });
        });

        document.querySelectorAll('[data-phase]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-phase]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                setScene(gallery.currentScene, btn.dataset.phase, gallery.mockState.weather);
            });
        });

        document.querySelectorAll('[data-weather]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-weather]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                setScene(gallery.currentScene, gallery.currentPhase, btn.dataset.weather);
            });
        });

        document.getElementById('run-all-tests').addEventListener('click', runAllTests);

        // Initialize
        initTests();
        startAnimation();
    </script>
</body>
</html>
